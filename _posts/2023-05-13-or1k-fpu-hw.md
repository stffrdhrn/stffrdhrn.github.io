---
title: OpenRISC FPU Port - Fixing Hardware
layout: post
date: 2023-05-13 09:50
categories: [ hardware, embedded, openrisc ]
---

In the [last article](http://a.c) we introduced the OpenRISC glibc FPU port and the effort
required to get user space FPU support into OpenRISC linux user applications.
We explained how the FPU port is a fullstack project covering:

 - Architecture Specification
 - Simulators and CPU implementations
 - Linux Kernel support
 - GCC Instructions and Soft FPU
 - Binutils/GDB Debugging Support
 - glibc support

In this entry we will cover updating *Simulators and CPU implementations* to support
the architecture changes which are called for as per the previous article.

 - Allowing usermode programs to update the FPCSR register
 - Defining tininess before routing

# Simulator Updates

The main simulator we use is QEMU.  The update was done in my
[OpenRISC user space FPCSR](https://lore.kernel.org/qemu-devel/20230511151000.381911-1-shorne@gmail.com)
qemu patch series.  The series was merged for the
[qemu 8.1](https://wiki.qemu.org/ChangeLog/8.1) release.

The updates were pretty straight forward and I split it into three changes:
 - Allowing FPCSR access in user mode.
 - Properly set the exception PC address on floating point exceptions.
 - Configuring the QEMU softfloat implementation to perform tininess check
   before rounding.

The first patch to *allow FPCSR access in user mode* was trivial, but required some
code structure changes making to diff look bigger than it really was.

The next patch to *properly set to exception PC address* fixed a long existing
bug.  Up until now OpenRISC userspace did not support FPU instructions and this
code path had not been tested.

When an exception occurs the exeption PC address (`EPCR`) stores the program
counter (`PC`) of the instruction that caused the exception.

  When the linux kernel handles a floating point exception it follows the path
[0xd00](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/openrisc/kernel/head.S?h=v6.4-rc7#n429) >
[_fpe_trap_handler](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/openrisc/kernel/entry.S?h=v6.4-rc7#n853) >
[do_fpe_trap](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/openrisc/kernel/traps.c?h=v6.4-rc7#n246).

The OS uses the `EPCR` to report the exceptio instruction address to
userspace via a [signal](https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04)
and to return to this address when exception handling is complete.  In
Linux the excption becomes a `SIGFPE` signal. The exception address will be set
in the `si_addr` field of the `siginfo_t` structure.

The reason QEMU was not setting the correct exception address is due to the way
qemu is implemented which optimizes performance.  QEMU executes target code
basic blocks that are translated to host native instructions.  Tracking of
target host address changes is done only when explicitly requested.

[QEMU Translation Internals](https://qemu.readthedocs.io/en/latest/devel/tcg.html)

The next patch to implement *tininess before rouding* was also trivial but
brought up a conversation about default NaN payloads.

...

# RTL Updates

The RTL updates look as follows

User mode support.

```
commit 6b1beaa871c02ccd570d8e6ad80f99bc4133aa26 (origin/fpcsr_free_access)
Author: Andrey Bacherov <bandvig@mail.ru>
Date:   Sat Jan 15 11:34:23 2022 +0300

    Make FPCSR is R/W accessible for both user- and supervisor- modes.

diff --git a/rtl/verilog/mor1kx_ctrl_cappuccino.v b/rtl/verilog/mor1kx_ctrl_cappuccino.v
index f9aec21..40d11cf 100644
--- a/rtl/verilog/mor1kx_ctrl_cappuccino.v
+++ b/rtl/verilog/mor1kx_ctrl_cappuccino.v
@@ -618,7 +618,7 @@ module mor1kx_ctrl_cappuccino
            spr_fpcsr[`OR1K_FPCSR_FPEE] <= 1'b0;
          end  
          else if ((spr_we & spr_access[`OR1K_SPR_SYS_BASE] &
-                  (spr_sr[`OR1K_SPR_SR_SM] & padv_ctrl | du_access)) &&
+                  (padv_ctrl | du_access)) &&
                   `SPR_OFFSET(spr_addr)==`SPR_OFFSET(`OR1K_SPR_FPCSR_ADDR)) begin
            spr_fpcsr <= spr_write_dat[`OR1K_FPCSR_WIDTH-1:0]; // update all fields
           `ifdef OR1K_FPCSR_MASK_FLAGS
```

The change to verilog shows that before when writng (`spr_we`) to the FPCSR (`OR1K_SPR_FPCSR_ADDR`) register
we used to check that the supervisor bit (`OR1K_SPR_SR_SM`) bit of the sr spr (`spr_sr`) is set.  That check
enforced supervisor mode only write access, removing this allows user space to write to the regsiter.

This implementation already allowed read access.

Updating for tininess was done in 2 of our main OpenRISC cores in the following
patches.

 - mor1kx          - [f2a78cc5d98](https://github.com/openrisc/mor1kx/commit/f2a78cc5d98123e63af4b23296795d95ffdfd854)
 - or1k_marocchino - [8be054f0bef](https://github.com/openrisc/or1k_marocchino/commit/8be054f0bef95bd94238509ced79ef5ec7a57417)

I will not go into details of these patches as I didnt write them.  But I
general they are medium size refactorings of the floating point unit.
